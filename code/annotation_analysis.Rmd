---
title: "Flowers text analysis"
author: "vboyce"
output:
  html_document:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, message=F, warning=F)
knitr::opts_chunk$set(dev = "png", dev.args = list(type = "cairo-png"))

library(here)
library(tidyverse)
library(rstanarm)
library(rstan)
library(tidybayes)
library(viridis)
library(cowplot)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
#for plotting
theme_set(theme_bw())
#Data import constants
date_start=lubridate::ymd('2021-07-19')
fig_path=here("figs")
read_data_path <- "data/processed_data/joined_data/"
annotation_path <- "data/annotations"
model_path <- "code/models"

show_summary_rstan <- function(model){
  badlist <- c("accept_stat__","divergent__","energy__","n_leapfrog__","sigma", "stepsize__","treedepth__")
  intervals <- gather_draws(model, `[a-zA-z_()]+`, regex=TRUE) |> mean_qi() |> filter(!.variable %in% badlist) |> 
    mutate(lower=round(.lower, digits=2),
           upper=round(.upper, digits=2),
           `Credible Interval`=str_c("[",lower,", ", upper,"]"),
           Term=.variable,
           Estimate=round(.value, digits=2)) %>% 
    select(Term, Estimate, `Credible Interval`)
  
  intervals
}

show_summary <- function(model){
  intervals <- gather_draws(model, `b_.*`, regex=T) %>% mean_qi()
  
  stats <- gather_draws(model, `b_.*`, regex=T) %>% 
    mutate(above_0=ifelse(.value>0, 1,0)) %>% 
    group_by(.variable) %>% 
    summarize(pct_above_0=mean(above_0)) %>% 
   mutate(`P-value equivalent` = signif(2*pmin(pct_above_0,1-pct_above_0), digits=2)) %>% 
    left_join(intervals, by=".variable") %>% 
    mutate(lower=round(.lower, digits=2),
           upper=round(.upper, digits=2),
           `Credible Interval`=str_c("[",lower,", ", upper,"]"),
           Term=str_sub(.variable, 3, -1),
           Estimate=round(.value, digits=2)) %>% 
    select(Term, Estimate, `Credible Interval`, `P-value equivalent`)
  
  stats
}

stats <- function(model, row){
  str_c(model[row,1],": Est=", model[row,2], ", CrI=", model[row,3])
}

stats_text  <- function(model, row){
  str_c( model[row,2], " (CrI=", model[row,3],")")
}
```

# Note 

I have annotated the transcripts of the full games marking what parts are referential (descriptive of a flower) and which flower (as best I can tell) it refers to. 

See https://docs.google.com/presentation/d/1qcDRZzHbLhE-fp6W9nKcbGouj4w01qCLCy-yt072iiY/edit?usp=sharing for the flower number - image correspondences. 

# Cogsci notes

Key points:

- Many of the key reduction findings from tangrams generalize to this situation. Specifically, we see utterance reduction over time and w/i group convergence for each image and divergence between images. This situation is different in that we have different stimuli (more natural) and the set up is collaborative and more free-form in what is talked about. These patterns hold for both the individual and group payoff structures. 

- One difference we see is that groups don't diverge (from each other). This may be dependent on stimulus properities (are there universal features of some of the images?) and group dynamics

- Conclusion: The key reference game findings have some generalizability. Settings like this one may be useful for encouraging discussion of a set of images and setting up partial knowledge situations. 

# Prep 

```{r}
d.games <- read_csv(here(read_data_path, "games.csv")) |> 
                        mutate(conditionName = condition, 
         condition = case_when(conditionName == "coopMulti" ~ "Shared Utilities",
                               conditionName == "competCartel" ~ "Individual Utilities",
                               conditionName == "coopCartel" ~ "Old Cooperative",
                               TRUE ~ conditionName)) |> 
  filter(chatEnabled) |> 
  select(gameId,conditionName, condition)

n_players = 3
n_rounds = 24

d.rounds <- read_csv(here(read_data_path,"rounds.csv"))
d.players <- read_csv(here(read_data_path, "players.csv")) |> select(playerId,name)
game_completion <- d.rounds %>% 
  group_by(gameId) %>% 
  tally() %>% 
  mutate(game_complete = n==n_players*n_rounds) %>%
  select(gameId, game_complete)

d.games.final <- d.games %>% 
  left_join(game_completion) %>% 
  replace_na(list(game_complete = FALSE, n_trials = 0)) |> 
  filter(game_complete)

d.rounds.final <-  d.rounds %>% 
  inner_join(d.games.final) %>% 
  filter(conditionName != "coopCartel",
         game_complete) |> 
  left_join(d.players) |> 
  #left_join(d.games) |> 
  select(gameId,trialNum, name, condition)


annotated <-  read_csv(here(annotation_path, "flowers_annotations.csv")) |> 
  filter(!is.na(normalized_span)) |> 
  inner_join(d.games.final) |> 
  mutate(numchar=str_length(span),
         numword=ifelse(numchar==0,0,str_count(span, "\\W+") + 1)) |> 
  mutate(flower=str_c(referent,color),
         player=str_c(gameId, name)) |> 
  select(gameId, player,name, flower, trialNum, pResp, normalized_span,color,numchar, numword, condition)


```

# How much data

```{r, message=T}

message("total utterances")
annotated |> filter(numword>0) |>  tally()

message("Utterances / game")

annotated |> filter(numword>0) |> group_by(gameId,condition) |> tally() |> pull(n) |> summary()

message("Utterances / flower")
annotated |> filter(numword>0) |> group_by(flower) |> tally() |> pull(n) |> summary()

```


# Word count basics

Take away -- across the condition manipulation, the number of utterances doesn't decrease, but the length of each one does. 

Graph could use finessing if going in paper. 

```{r, fig.height=4, fig.width=8}

sum_words <- annotated %>% filter(numword>0) |>  group_by(trialNum, gameId,condition) %>% summarize(sum_char=sum(numchar),
                                           sum_word=sum(numword))
  
     total <-  ggplot(sum_words,aes(x=trialNum+1,y=sum_word, color=condition))+
   # geom_smooth(method="lm", se=T)+
            geom_smooth(method="lm", formula=y~poly(x,2), se=T)+

        geom_jitter(alpha=.1, width=.2, height=.5)+
        labs(y="Referential Words per trial per game", x="Trial Number", color="")+
        theme(legend.position="bottom", legend.title=element_blank())+
        scale_x_continuous(limits=c(1,24), breaks=c(6,12,18,24))+
        scale_color_brewer(palette="Dark2")

    legend <- get_legend(total)
    
    all_words <- total+theme(legend.position = "none") 
      
        words <- ggplot(annotated |> filter(numword>0),aes(x=trialNum,y=numword, color=condition))+geom_jitter(alpha=.1)+ geom_smooth()+
          labs(y="Words per reference expression", x="Trial Number")+
        theme(legend.position="none", legend.title=element_blank())+
        scale_x_continuous(limits=c(1,24), breaks=c(6,12,18,24))+
        scale_color_brewer(palette="Dark2")
        
        utts <- annotated |> filter(numword>0) |> group_by(gameId, trialNum, condition) |> tally() |> 
  ggplot(aes(x=trialNum, y=n, color=condition))+geom_jitter(alpha=.02)+geom_smooth()+
          labs(y="Reference expressions  per trial per game", x="Trial Number")+
        theme(legend.position="none", legend.title=element_blank())+
        scale_x_continuous(limits=c(1,24), breaks=c(6,12,18,24))+
        scale_color_brewer(palette="Dark2")
        
        top <- plot_grid(all_words, words, utts,nrow=1)
        plot_grid(top, legend, nrow=2, rel_heights=c(1,.1))

```

# How many different flowers described / trial?

We can probably give this as summary stats and not as graph

Per game

```{r}
possible <- d.rounds.final |> select(-name) |> unique()

annotated |> group_by(gameId, trialNum, condition) |> select(flower) |> unique() |> tally() |> full_join(possible) |> 
  mutate(n=ifelse(is.na(n),0,n)) |> 
  ggplot(aes(x=trialNum, y=n, color=condition))+geom_jitter(height=.25, alpha=.2)+geom_smooth()+
          labs(y="Distinct flowers referenced per trial", x="Trial Number")+
        theme(legend.position="none", legend.title=element_blank())+
        scale_x_continuous(limits=c(1,24), breaks=c(6,12,18,24))+
        scale_color_brewer(palette="Dark2")
```

Per person

```{r}

annotated |> group_by(gameId, trialNum, condition, player, name) |> select(flower) |> unique() |> tally() |> full_join(d.rounds.final) |> 
  mutate(n=ifelse(is.na(n),0,n)) |> 

  ggplot(aes(x=trialNum, y=n, color=condition))+geom_jitter(height=.25, alpha=.1)+geom_smooth()+
          labs(y="Distinct flowers referenced per player per trial", x="Trial Number")+
        theme(legend.position="none", legend.title=element_blank())+
        scale_x_continuous(limits=c(1,24), breaks=c(6,12,18,24))+
        scale_color_brewer(palette="Dark2")
```




## Model

```{r,eval=F, include=F}

m1 <- stan_lmer(numword ~ trialNum + condition + (1|gameId)+ (1|player)+(1|flower), data=annotated) |> write_rds(here(model_path,"m1.rds"))

```

```{r}
m1 <- read_rds(here(model_path,"m1.rds"))
m1
#prior_summary(m1)
show_summary_rstan(m1)
```

# Sbert notes

Some pre-commentary on analytic choices:
- it's unclear whether we should be looking at referential statements individually (i.e. treating anything that occured as a separate utterance, after a line break, as separate) or concatenating everything Laju said about flower yellow3 into one statement. I think the first is generally better since sometimes a flower is described twice (perhaps in the same way), as in "the best values are 3 in a row and big fluffy" ... "okay, I'll take big fluffy". But there are also times when someone has a line break before continuing/clarifying a description. For now we go with single utterances.

- Unlike tangrams where there was a very clear cut every item gets described once every round by every group, here we have no such guarantees! So there's a big question of what scale to use for "time block". In some within game cases it might make sense to compare utterances within a single round (for distinctiveness of different descriptions or if multiple describe the same flower differently). It also might make sense to treat round as the semi-continuous variable that it is for some modelling where we can eventually see that farther away pairs do something. But for now, I'm going to divide the game into quarters (sets of 6 rounds) and pretend that we have 4 time points. This is arbitrary and preliminary but it's easy to do viz with.


```{r, include=F,}

 d.raw_chat <- read_csv(here(paste(read_data_path, 
                                   "raw_chat.csv", 
                                   sep="")),
                       col_types = cols()) %>% distinct() |> 
   select(gameId, playerId) |> unique()
 
 d.players <- read_csv(here(paste(read_data_path, "players.csv", sep = "")),
                       col_types = cols()) %>% distinct() |> select(playerId,name) |> inner_join(d.raw_chat)

 sbert_single <- read_csv(here(annotation_path,"pre_sbert.csv"))|> 
    left_join(d.players) |> left_join(d.games.final) |> mutate(seen="game") |> 
   select(playerId, gameId, condition, text=normalized_span,referent, color, trialNum, seen) |> bind_cols(readRDS(here(annotation_path,'post_sbert.RData'))  %>% as_tibble())

sbert_post_test <- read_csv(here(annotation_path,"post_test_pre_sbert.csv")) |> 
  mutate(trialNum=25) |> 
 bind_cols(readRDS(here(annotation_path,'post_sbert_post_test.RData'))  %>% as_tibble()) |> inner_join(d.games) |> 
   select(playerId, gameId, condition, text,referent=num, color, trialNum, seen, starts_with("V"))

sbert_all <- sbert_single |> union(sbert_post_test)
F_mat <- sbert_all %>% select(starts_with("...")) %>% as.matrix() #Features
M_mat <- sbert_all %>% 
  select(-starts_with("V")) %>% 
  mutate(feature_ind=row_number(),
         sixth=case_when(
           trialNum < 4 ~ 1,
          trialNum < 8 ~ 2,
          trialNum < 12 ~ 3,
          trialNum < 16 ~ 4,
          trialNum < 20 ~ 5,
          trialNum < 24 ~ 6,
          trialNum > 24 ~ 7
  ))
```


```{r helpers}
# note: cor expects features to be in columns so we transpose
get_sim_matrix = function(df, F_mat, method = 'cosine') {
  feats = F_mat[df$feature_ind,]
  if(method == 'cor') {
    return(cor(t(feats), method = 'pearson'))
  } else if (method == 'euclidean') {
    return(as.matrix(dist(feats, method = 'euclidean')))
  } else if (method == 'cosine') {
    return(as.matrix(lsa::cosine(t(feats))))
  } else {
    stop(paste0('unknown method', method))
  }
}

# note this does de-duplicated version
flatten_sim_matrix <- function(cormat, ids) {
  ut <- upper.tri(cormat)
  data.frame(
    dim1 = ids[row(cormat)[ut]],
    dim2 = ids[col(cormat)[ut]],
    sim  = as.numeric(cormat[ut])
  ) %>%
    mutate(dim1 = as.character(dim1),
           dim2 = as.character(dim2))
}

make_across_df <- function(M_mat, F_mat, method) {
  M_mat %>%
    do(flatten_sim_matrix(get_sim_matrix(., F_mat, method = method),
                          as.character(.$combinedId)))
}
```

# Sbert pictures 

These have quadratic smooths fit onto them, to allow for curvature, but no reason to choose this curve and not another. 

## During game

```{r }

# by trial
flower_all <- M_mat %>% 
  filter(seen %in% c("game")) |> 
  group_by(color,condition) %>% 
  mutate(combinedId=str_c(referent,"_", trialNum, "_",gameId,"_",playerId)) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, c("ref1", "trialNum1","game1","player1"), convert=T) |> 
  separate(dim2, c("ref2", "trialNum2", "game2", "player2"), convert=T) |> 
 # rename(referent1=dim1,referent2=dim2) %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  #filter(ref1!=ref2) %>% 
  mutate(earlier=ifelse(trialNum1>trialNum2,trialNum2, trialNum1) |> as.numeric(),
         later=ifelse(trialNum1>trialNum2, trialNum1,trialNum2) |> as.numeric()) |> 
  ungroup()
```

```{r}
flower_all|> 
  filter(later-earlier<3) |> 
  mutate(distance=case_when(
    player1==player2 ~ "Same person",
    game1==game2 ~ "same game",
    T ~ "different game"),
    same_flower=ifelse(ref1==ref2, "Same flower", "diff flower")
  ) |> 
ggplot( aes(x=later,y=sim,color=condition))+     
  stat_summary(aes(group=str_c(color,condition), color=condition),fun.data = "mean_cl_boot", position = position_dodge(width=.3), alpha=.3, geom="point")+
  geom_smooth(formula=y~poly(x,2))+facet_grid(same_flower~distance)+theme(legend.position="bottom", legend.title=element_blank())+
        scale_x_continuous(limits=c(1,24), breaks=c(6,12,18,24))+
        scale_color_brewer(palette="Dark2")

```


Comparing utterances within rounds that were up to 2 apart, round coded as the later (so 10-12,11-12 and 12-12 will all contribute to "12"). Up to 2 apart is somewhat arbitrary, not sure what the right rolling window to do is. 

Take aways:
 - descriptions to the same flower within game (either same person or not) become more similar
 - descriptions to the same flower across games become (slightly) less similar
 - descriptions to different flowers become less similar (regardless of between/within game)
 


## Between game and end

We can treat what someone wrote at the end as the convention and then compare how similar this is to earlier utterances by them and their group mates.

Big question is whether the end utts need cleaning (which probably yes?)

We see that for the same flower, similarity to the end utt increases over blocks both within individual and indiv - other group mate (this is all within a game)

```{r }

# by trial
to_end <- M_mat %>% 
  filter(seen %in% c("game", "own")) |> 
  group_by(gameId,color,condition) %>% 
  mutate(combinedId=str_c(referent,"_", trialNum, "_",seen,"_",playerId)) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, c("ref1", "trialNum1","seen1","player1"), convert=T) |> 
  separate(dim2, c("ref2", "trialNum2", "seen2", "player2"), convert=T) |> 
 # rename(referent1=dim1,referent2=dim2) %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  filter(seen1!=seen2) %>% 
  mutate(earlier=ifelse(trialNum1>trialNum2,trialNum2, trialNum1) |> as.numeric(),
         later=ifelse(trialNum1>trialNum2, trialNum1,trialNum2) |> as.numeric()) |> 
  ungroup()
```

Comparing utterances earlier to post-game descriptions. 

General question of how to display these things -- what should be color v faceting and what to do for the dots. 

```{r}
to_end|> 
  mutate(distance=case_when(
    player1==player2 ~ "Same person",
    T ~ "same game"),
        same_flower=ifelse(ref1==ref2, "Same flower", "diff flower")
) |> 
ggplot( aes(x=earlier,y=sim,color=condition))+     
  stat_summary(aes(group=str_c(color,condition), color=condition),fun.data = "mean_cl_boot", position = position_dodge(width=.3), alpha=.3, geom="point")+
  geom_smooth(formula=y~poly(x,2))+facet_grid(same_flower~distance)+theme(legend.position="bottom", legend.title=element_blank())+
        scale_x_continuous(limits=c(1,24), breaks=c(6,12,18,24))+
        scale_color_brewer(palette="Dark2")

```

##  Within end-stuff

We can look at how converged people are (or are not) by comparing what they say at the end.

Each person was asked for names ( ~ "how would you label this to your group") for the 12 images they were seeing and then for 4 from a different color palette. 

Own = color you saw all game

Other = the color you didn't see

Mixed = own for one person, other for other person

```{r }

# by trial
in_end <- M_mat %>% 
  filter(seen %in% c("other", "own")) |> 
  group_by(color,condition) %>% 
  mutate(combinedId=str_c(referent, "_",seen,"_", gameId, "_",playerId)) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, c("ref1", "seen1","game1","player1"), convert=T) |> 
  separate(dim2, c("ref2",  "seen2","game2", "player2"), convert=T) |> 
 # rename(referent1=dim1,referent2=dim2) %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  ungroup()
```

```{r}
in_end|> 
  mutate(distance=case_when(
    player1==player2 ~ "Same person",
    game1==game2 ~ "same game",
    T ~ "different game"),
    same_flower=ifelse(ref1==ref2, "Same flower", "diff flower"),
    same_color=case_when(
  seen1=="own" & seen2=="own" ~ "own",
  seen2=="other" & seen1=="other" ~ "other",
  T ~"mixed"
  ))|> 
ggplot( aes(x=same_color,y=sim,color=condition))+     
  stat_summary(fun.data = "mean_cl_boot", position = position_dodge(width=.3))+
facet_grid(same_flower~distance)+theme(legend.position="bottom", legend.title=element_blank())+
        scale_color_brewer(palette="Dark2")
```

Not sure how to show spread here. Or how to do a viz that allows for comparisons. 

Take aways:

- People use more similar descriptions for two flowers that weren't in their set than those that were (checks out -- in set ones have been described and diverged)
- This same thing holds (with overall lower sims) for group-mates
- Group mates are more similar in how they describe flowers they've seen (v not) (at least in shared utils)
- not sure how to interpret the diff game -- this is the baseline? Maybe it's just that you're more similar for the same flower versus different regardless? (also this is baseline for other panels)

# Future things

- have we tried log space? 
- Could do more end game -- earlier comparisons
- tSNE??
- Models of (some of ?) what's shown in forgoing graphs
- CLIP ????
- clean up end utts? 
- are there interesting lang -- performance connections ? 

## Boring diligence
- Double check that non-talkers aren't in this data at all (end game joins). Consider coding and grouping end stuff by what color they usually saw during the game
- do sbert a different way and confirm (split v aggregate?)

