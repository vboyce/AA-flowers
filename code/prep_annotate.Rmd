---
title: "prep_annotating"
author: "vboyce"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, message=F, warning=F)
knitr::opts_chunk$set(dev = "png", dev.args = list(type = "cairo-png"))

library(here)
library(tidyverse)

#for plotting
theme_set(theme_bw())
#Data import constants
date_start=lubridate::ymd('2021-07-19')
fig_path=here("figs")
read_data_path <- "data/processed_data/joined_data/"
annotation_path <- "data/annotations"
```
# Summary Processing
## Read data

```{r read-data}
d.players <- read_csv(here(paste(read_data_path, "players.csv", sep = "")),
                      col_types = cols()) %>% distinct()
d.games <- read_csv(here(paste(read_data_path, "games.csv", sep = "")),
                      col_types = cols()) %>% distinct()
d.rounds <- read_csv(here(paste(read_data_path, 
                                "rounds.csv", 
                                sep="")),
                      col_types = cols()) %>% distinct() 
d.raw_chat <- read_csv(here(paste(read_data_path, 
                                  "raw_chat.csv", 
                                  sep="")),
                      col_types = cols()) %>% distinct()
d.contexts <- read_csv(here(paste(read_data_path, 
                                  "contexts.csv", 
                                  sep="")),
                      col_types = cols()) %>% distinct()
d.feedback <- read_csv(here(paste(read_data_path, 
                                  "feedback.csv", 
                                  sep = "")),
                      col_types = cols()) %>% distinct()
d.demographics <- read_csv(here(paste(read_data_path,
                                      "demographics.csv", 
                                      sep="")),
                      col_types = cols()) %>% distinct()
```

## Rename Conditions
Rename conditions for readability/alignment with ms
```{r}
d.games <- d.games %>% 
  mutate(conditionName = condition, 
         condition = case_when(conditionName == "coopMulti" ~ "Shared Utilities",
                               conditionName == "competCartel" ~ "Individual Utilities",
                               conditionName == "coopCartel" ~ "Old Cooperative",
                               TRUE ~ conditionName))
```

## Identify complete games

For the purposes of this ms, we're removing all unfinished games from the analyses 
```{r}
n_players = 3
n_rounds = 24

game_completion <- d.rounds %>% 
  group_by(gameId) %>% 
  tally() %>% 
  mutate(game_complete = n==n_players*n_rounds) %>%
  rename(n_trials = n)

d.games.final <- d.games %>% 
  left_join(game_completion) %>% 
  replace_na(list(game_complete = FALSE, n_trials = 0))

d.games.conditions <- d.games.final %>% 
  select(gameId, color, condition, chatEnabled, game_complete) %>% 
  mutate(languageCondition = ifelse(chatEnabled, "Lang", "Nonlang"),
         fullCondition = paste(condition, languageCondition, sep = "-"))

d.rounds.final <-  d.rounds %>% 
  left_join(d.games.final %>% 
              select(gameId, conditionName, condition,color, chatEnabled, game_complete)) %>% 
  filter(conditionName != "coopCartel",
         game_complete)

d.raw_chat.final <- d.raw_chat %>% 
  left_join(d.games.final %>% 
              select(gameId, conditionName, condition, game_complete)) %>%
  filter(game_complete)

```

# Want to find a "best" game to start with

```{r}
d.rounds.final %>% filter(game_complete) %>% filter(chatEnabled) %>% 
  group_by(gameId, conditionName,condition, ) %>% summarise(utils=sum(playerUtility)) %>% arrange(desc(utils))

# let's look at gameId == QHkfso2yMgbbziE7r first
```

```{r}


good_rounds <- d.rounds.final %>% filter(gameId=="QHkfso2yMgbbziE7r") %>% 
  select(playerId,playerResponse,roundId,gameId) %>% 
  separate(playerResponse, into=c("color","pResp"))

good_contexts <- d.contexts %>% filter(gameId=="QHkfso2yMgbbziE7r") %>% 
  select(roundId, gameId, label, utility) %>% 
  separate(label, into=c("color", "num")) %>% 
  mutate(labelutil=str_c(num,":",utility)) %>% 
  group_by(roundId, gameId, color) %>% 
  arrange(desc(utility)) %>% 
  summarize(flowers=str_c(labelutil,collapse=", "))

good_chat <- d.raw_chat.final %>% filter(gameId=="QHkfso2yMgbbziE7r") %>% 
  left_join(d.players %>% select(playerId, name)) %>% 
  rename(roundId=roundID) %>% 
  left_join(good_contexts) %>% 
  left_join(good_rounds) %>% 
  mutate(rowid=row_number()) %>% 
  select(rowid,trialNum,name, pResp, text, flowers, color) %>% 
  filter(!is.na(text)) 

```
# Write all games to tsv for coding
```{r}


good_rounds <- d.rounds.final %>% 
  select(playerId,playerResponse,roundId,gameId) %>% 
  separate(playerResponse, into=c("color","pResp"))

good_contexts <- d.contexts %>% 
  select(roundId, gameId, label, utility) %>% 
  separate(label, into=c("color", "num")) %>% 
  mutate(labelutil=str_c(num,":",utility)) %>% 
  group_by(roundId, gameId, color) %>% 
  arrange(desc(utility)) %>% 
  summarize(flowers=str_c(labelutil,collapse=", "))

good_chat <- d.raw_chat.final %>% 
  left_join(d.players %>% select(playerId, name)) %>% 
  rename(roundId=roundID) %>% 
  left_join(good_contexts) %>% 
  left_join(good_rounds) %>% 
  mutate(rowid=row_number(),
         span="",
         referent="",) %>% 
  select(gameId,rowid,trialNum,name, pResp, text,span, referent, flowers, color) %>% 
  filter(!is.na(text)) %>% 
  write_tsv(here(annotation_path, "pre_annotation.tsv"))

```
# Choose games for agreement coding

```{r, include=F}
agreement_sample <- good_chat %>% filter(gameId %in% c("Rq47E8uzWFKm4CBPJ","Etbyk29DvPTqmSJM7")) %>% write_tsv(here(annotation_path, "pre_agreement.tsv"))
```
# Interannotator agreement

```{r, include=F}
vb <- read_csv(here(annotation_path, "vb_agreement.csv")) %>% rename(vb_span=span,vb_referent=referent) %>% 
  mutate(vb_span=ifelse(str_starts(vb_span, "the "), str_sub(vb_span, 5, -1), vb_span)) %>% 
  mutate(row=row_number())
bl <- read_csv(here(annotation_path, "bl_agreement.csv")) %>% rename(bl_span=span,bl_referent=referent) %>% 
  mutate(bl_span=str_sub(bl_span, 2,-2)) %>% #remove quote marks
  mutate(row=row_number())

both <- vb %>% full_join(bl) %>% 
  mutate(same_span=ifelse(vb_span==bl_span, 1,0),
         same_ref=ifelse(vb_referent==bl_referent, 1,0)) %>% 
  select(text,vb_span, bl_span, vb_referent,bl_referent, same_span, same_ref) 

differ <- both %>% 
  filter(same_span==0)


count <- both %>% group_by(same_ref) %>% tally()

```

# Quality control
We can run some sanity checks on annotations -- 

First - the identified flower should be one of the available options.
Second - the span should (usually) be a substring of the text 

```{r}
annotated <-  read_csv(here(annotation_path, "flowers_annotations.csv")) |> 
  filter(!is.na(span)) |> 
  mutate(flower_list=str_split(flowers,", "),
         flower_list=map(flower_list,~str_replace(.,":.+","")),
         referent_char=as.character(referent),
         referent_good=map2(referent_char,flower_list, ~.x %in% .y),
         span_good=map2(text,span, ~str_detect(.x,coll(.y))))

#filter(annotated,referent_good==F)  |> View() # Note: originally 35, caught some errors, one that remains I believe is actually talking about an image from prior round!

#filter(annotated,span_good==F)  |> View() #Note: dowm from more that were incorrectly copied. The ones left are either as a result of duplicate spacing not copying
# or intentional when someone wrote description "is my best" continued description

```

** Note ** : there is probably inconsistency in how dubiously referential things like "same as last time" or "that one" are coded. Actually descriptions are probably well coded.
All flowers were identified, some with lower justification/certainty than others. 

# Sbert prep

It's unclear how we want to do sbert -- one way would be to group by speaker+target and concatenate, the other would be to respect newlines. 

```{r}
pre_sbert <- annotated |> filter(!is.na(normalized_span)) |> 
  select(gameId, trialNum,name,normalized_span, referent,color) |> 
  write_csv(here(annotation_path, "pre_sbert.csv"))

pre_sbert_concat <- pre_sbert |> group_by(gameId, trialNum, name, referent, color) |> 
    summarize(normalized_span=str_c(normalized_span, collapse=" ")) |> 
  write_csv(here(annotation_path, "pre_sbert_concat.csv"))


```

```{r, include=F, eval=F}
library(reticulate)
np <- import("numpy")
mat = np$load(here(annotation_path,'post_sbert.npy'))
saveRDS(mat,here(annotation_path,'post_sbert.RData'))
```

```{r, include=F, eval=F}
library(reticulate)
np <- import("numpy")
mat = np$load(here(annotation_path,'post_sbert_concat.npy'))
saveRDS(mat,here(annotation_path,'post_sbert_concat.RData'))
```

# Sbert prep on end stuff

```{r}
library(jsonlite)

ParseJSONColumn <- function(x) {
  str_c("[ ", str_c(x, collapse = ",", sep=" "), " ]")  %>% 
    fromJSON(flatten = T)
}
d.players <- read_csv(here(paste(read_data_path, "players.csv", sep = "")),
                      col_types = cols()) %>% distinct() |> 
  select(playerId,own=flower_labels,other=otherflower_labels) |> 
  inner_join(d.rounds.final |> select(gameId, playerId, conditionName, color) |> unique()) |> 
  mutate(own= ifelse(is.na(own), '{}', own)) %>%
  mutate(other = ifelse(is.na(other), '{}', other)) %>%
  mutate(own = map(own, .f = ParseJSONColumn)) %>% 
  mutate(other =  map(other, .f = ParseJSONColumn)) %>% 
  unnest(cols=c(own,other), names_sep=":") %>% 
  pivot_longer(cols=starts_with("own")|starts_with("other")) %>% 
  filter(!is.na(value)) %>% 
  filter(value!="") %>% 
  separate(name, into=c("seen","color","num")) %>% 
  rename(text=value) %>% 
  mutate(text = gsub("[/?/.]", ' ', text),
         text = str_squish(text),
         utt_length_chars = str_length(text), 
         utt_length_words = str_count(text, "\\W+") + 1) |> write_csv(here(annotation_path,"post_test.csv"))


```

```{r, include=F, eval=F}
library(reticulate)
np <- import("numpy")
mat = np$load(here(annotation_path,'post_sbert_post_test.npy'))
saveRDS(mat,here(annotation_path,'post_sbert_post_test.RData'))
```