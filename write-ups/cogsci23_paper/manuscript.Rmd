---
title: "Communicative reduction in referring expressions in a multi-player negotation game"
bibliography: [ aaflowers.bib]
csl: apa6.csl
document-params: "10pt, letterpaper"

author-information: > 
    \author{{\large \bf Veronica Boyce (vboyce@stanford.edu)} \\ Department of Psychology, Stanford University
    \AND {\large \bf Michael C. Frank (mcfrank@stanford.edu)} \\ Department of Psychology, Stanford University}

abstract: >
    Reduction of referring expressions to short conventionalized terms is found robustly in dyadic repeated reference games when the target images are initially difficult to name. Establishing reference is crucial to many conversations with different goals and more complex motivations; thus, it is useful to look at how the findings from reference games, where participants share the explicit goal of establishing joint reference, carry over into situations where participants have different overarching goals. In the current work, we analyse a dataset where reference was embedded in strategic 3- player negotiation and coordination games. In these more complex games, we found that the patterns of reduction and convergence to conventions held across two different incentive conditions, with some suggestive differences between the conditions.  
    
keywords: >
    Convention formation; reference games; reduction of referring expressions; multi-party communication;
    
output: cogsci2016::cogsci_paper
#final-submission: \cogscifinalcopy
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=3, fig.height=3, fig.crop = F, 
                      fig.pos = "tb", fig.path='figs/',
                      echo=F, warning=F, cache=F, 
                      message=F, sanitize = T)
library(here)
library(tidyverse)
#library(rstanarm)
#library(rstan)
#library(tidybayes)
library(viridis)
library(cowplot)
#library(lsa)
library(kableExtra)
#rstan_options(auto_write = TRUE)
#options(mc.cores = parallel::detectCores())
#for plotting
theme_set(theme_bw())

#Data import constants
date_start=lubridate::ymd('2021-07-19')
fig_path=here("write-ups/cogsci23_paper/figs")
read_data_path <- "data/processed_data/joined_data/"
annotation_path <- "data/annotations"
model_path <- "code/models"

stats <- function(model, row){
  str_c(model[row,1],": Est=", model[row,2], ", CrI=", model[row,3])
}

stats_text  <- function(model, row){
  str_c( model[row,2], " CrI=", model[row,3],"")
}
```

```{r}
d.games <- read_csv(here(read_data_path, "games.csv")) |> 
                        mutate(conditionName = condition, 
         condition = case_when(conditionName == "coopMulti" ~ "Shared Utilities",
                               conditionName == "competCartel" ~ "Individual Utilities",
                               conditionName == "coopCartel" ~ "Old Cooperative",
                               TRUE ~ conditionName)) |> 
  filter(chatEnabled) |> 
  select(gameId,conditionName, condition)

n_players = 3
n_rounds = 24

# d.games |> filter(conditionName!="Old Cooperative") |> group_by(conditionName) |> tally()
d.rounds <- read_csv(here(read_data_path,"rounds.csv"))
d.players <- read_csv(here(read_data_path, "players.csv")) |> select(playerId,name)
game_completion <- d.rounds %>% 
  group_by(gameId) %>% 
  tally() %>% 
  mutate(game_complete = n==n_players*n_rounds) %>%
  select(gameId, game_complete)

d.games.final <- d.games %>% 
  left_join(game_completion) %>% 
  replace_na(list(game_complete = FALSE, n_trials = 0)) |> 
  filter(game_complete)

d.rounds.final <-  d.rounds %>% 
  inner_join(d.games.final) %>% 
  filter(conditionName != "coopCartel",
         game_complete) |> 
  left_join(d.players) |> 
  #left_join(d.games) |> 
  select(gameId,trialNum, name, condition)


annotated <-  read_csv(here(annotation_path, "flowers_annotations.csv")) |> 
  filter(!is.na(normalized_span)) |> 
  inner_join(d.games.final) |> 
  mutate(numchar=str_length(span),
         numword=ifelse(numchar==0,0,str_count(span, "\\W+") + 1)) |> 
  mutate(flower=str_c(referent,color),
         player=str_c(gameId, name)) |> 
  select(gameId, player,name, flower, trialNum, pResp, normalized_span,color,numchar, numword, condition)


```

Successful communication is grounded in a shared understanding of what utterances mean in the context they are produced in. Whether the communicative goals are cooperative or adversarial, interlocuters need to establish joint reference to be effective. In many cases conventional word meanings are enough, but there are also contexts where objects to be referred to are not easy to distinguish. In these situations, establishing reference is more difficult, but no less important. <!--For one, in everyday communication, establishing reference rarely happens in isolation but is usually a subgoal in a larger conversational goal. The overall goal might be cooperative, such as in asking for a piece of kitchen equipment while cooking together, but it can also be adversarial, such as in a negotiation where the assets to be divied up must be referenced. In the reference game context, the goal is always cooperative, to match the images or get them in the same order. -->

The formation of these ad-hoc referring expressions has been studied extensively in the context of dyadic reference games [@clarkReferringCollaborativeProcess1986; @krauss1964changes]. In these, two participants see a set of images (often abstract shapes) and one person is tasked with identifying an image so the other person can pick it out. People can be very successful at this task, achieving high levels of matches. Over repeated reference to the same images, pairs develop shorthand names for the images, leading to shorter descriptions in later repetitions. These nicknames conventionalize with a pair, as they tend to stick to the same description, but are idiosyncratic and differ between pairs. This has been a well-studied microcosm for understanding reference which has proven useful for testing theories about how referring expressions originate, how expressions are designed, and when they change [@brennan1996conceptual; @metzing2003conceptual; @leung2020parents; @weber2003; @yoonAudienceDesignMultiparty2019]. 

The implicit theoretical claim is that reduction to partner-specific conventions occurs whenever people interact repeatedly in ways that require reference to some objects without adequate conventional names. Do these phenomena generalize beyond artificial reference game environments?

Our current work begins to address this by looking for these phenomena in a slightly more naturalistic setting. The conversational goals of reference games are not representative of typical language use. In everyday communication, establishing reference is often an instrumental subgoal in a larger conversation. The overall task may be cooperative, such as asking for kitchen equipment while cooking together, or adversarial, such as identifying items while negotiating a division of assets. In the reference game context, the goal is explicitly cooperative: match corresponding images. 






```{r interface, fig.env = "figure*", fig.pos = "t!", fig.width=6, fig.height=2, fig.align = "center", set.cap.width=T, num.cols.cap=2, fig.cap = "Player interface. Panel A shows the selection phase, where each participant sees 6 flowers, 4 with value bars. Panel B shows the feedback stage, after all players have selected. When multiple players select the same flower, they recieve a lower value rather than what is shown.  \\label{interface}", cache=FALSE}

selection <- png::readPNG(here(fig_path, "selection.png"))

feedback <- png::readPNG(here(fig_path, "feedback.png"))

a <- ggdraw() + draw_image(selection)
b <- ggdraw()+draw_image(feedback)

plot_grid(a,b, labels="AUTO")
```

@mankewitz2021 bridged the gap between reference games with hard-to-name objects and negotation datsets with easily nameable objects. They created a 3-person game where players each selected what flowers to grow from a set of 6 flowers with variable and partially hidden value. Players got the value of the flower only if they were the only one to select it, which incentivized coordination and negotiation. However, all the flowers shown were the same color, so they were not easily nameable, and the flowers repeated, leading to opportunities for ad-hoc conventionalization. This game structure encouraged players to describe flowers while never explicitly telling a player to refer to any specific flower. The experiment had two conditions, one where players within a group won points together (and thus had fully aligned incentives) and another where they won points as individuals (and didn't). @mankewitz2021 found a slight decrease in language over the course of the games, but they did not conduct a detailed analysis to assess whether the decreases in words were associated with shorter and more conventionalized referring expressions. Here, we separated out the referring expressions in order to check for patterns of convention-formation. 

Our current work addresses whether participants in a complex, multi-player strategic game with differing incentives and shared knowledge were able to develop conventionalized reference expressions. We explored whether the phenomena found in classic dyadic iterated reference games extended to this more naturalistic domain, and whether they differed across the individual and shared incentive conditions. The key questions we addressed were:

1. Did the referring expressions reduce over time? 

2. How did referring expressions change within and between groups over the course of the games?

3. How did the different incentive conditions influence the referring expressions? 

Historically, studies of convention formation have had to rely on proxies such as reduction, subjective judgements of similarity, and and manual measures of lexical overlap. In contrast, we use natural language processing tools for mapping sentences to semantic vector spaces to quantify semantic similarities between sentences, following recent work by @hawkins2020 and @boyce2022. 

# Methods

This paper presents a reanalysis of data from @mankewitz2021. We describe both the original data collection and the additional data processing done for reanalysis. 

## Procedure
As described in @mankewitz2021, participants played a real-time coordination game in groups of three, implemented using Empirica [@almaatouqEmpiricaVirtualLab2020]. On each trial, each group saw a set of 6 flower images (Figure \ref{interface}A) . Each participant saw the values for 4 of the flowers (represented as a colored bar), such that each flower's value was hidden from one participant. Players could coordinate and discuss using a chat box before each selected a flower. If one player selected a flower, it was worth the shown reward; if multiple players collided and selected the same flower, they each got a lower reward instead (Figure \ref{interface}B). Players needed to communicate about the flowers in order to coordinate their selections. The rewards translated in a monetary bonus for the participants at the end of the game. 

In *individual utility* games, each player earned points for the flowers they selected; in the *shared utility* games, the points were averaged together, and all players in a game got the same reward. This made for slightly different incentives; in an individual game, players wanted to maximize the rewards of flowers they selected, and only cared about avoiding collisions with other players' selections; in a shared game, players wanted their teammates to select different high reward flowers, and were indifferent on who selected the highest one. 

Each game was assigned a color of flower (white, red, yellow, purple) and the flower images were drawn from a set of 12 for that color, so players saw the same flowers repeatedly across the game, in different combinations. Each game consisted of 24 trials. Different flowers of the same color created situations where players did not have established names for the flowers in context and needed to develop shared referring expressions to clearly communicate with their partners. 

After the game, players were asked how they would describe each of the images to their teammates. 

## Participants
@mankewitz2021 recruited `r 3 *(d.games |> filter(conditionName!="Old Cooperative") |> nrow())` participants for 25 3-person games in each of the individual and shared utilities conditions. Some games did not complete the full 24 trials because participants dropped out early.  We excluded incomplete games from analyses, which left us with `r d.games.final |> filter(condition=="Individual Utilities") |> nrow()` games in the individual utilities condition and `r d.games.final |> filter(condition=="Shared Utilities") |> nrow()` in the shared utilities condition (`r 3*(d.games.final |> nrow())` participants included in the analyses). 

```{r wordcount, fig.env = "figure*", fig.pos = "h", fig.align = "center", set.cap.width=T, num.cols.cap=2, fig.cap = "Words produced in referring expressions across trials in both conditions. A: Total words of referring language per game per trial. B: Words in each reference expression by trial. C: Total number of reference expressions per game per trial. \\label{wordcount}", fig.height=2, fig.width=7}

possible <- d.rounds.final |> select(-name) |> unique()

sum_words <- annotated %>% filter(numword>0) |>  group_by(trialNum, gameId,condition) %>% summarize(sum_char=sum(numchar),
                                           sum_word=sum(numword)) |> full_join(possible) |> 
  mutate(sum_char=ifelse(is.na(sum_char),0,sum_char),
         sum_word=ifelse(is.na(sum_word),0,sum_word))
  
     total <-  ggplot(sum_words,aes(x=trialNum+1,y=sum_word, color=condition))+
   # geom_smooth(method="lm", se=T)+
            geom_smooth(method="lm", formula=y~poly(x,2), se=T)+

        geom_jitter(alpha=.05, width=.2, height=.5)+
        labs(y="Words in reference \n expressions per trial", x="Trial Number", color="")+
        theme(legend.position="bottom", legend.title=element_blank(), axis.title = element_text(size=8))+
        scale_x_continuous(limits=c(1,24), breaks=c(6,12,18,24))+
        ggthemes::scale_color_solarized()+
        guides(color = guide_legend(override.aes = list(linetype = NA, alpha=1, fill=NA, size=5) ) )


    legend <- get_legend(total)
    
    all_words <- total+theme(legend.position = "none") 
      
        words <- ggplot(annotated |> filter(numword>0),aes(x=trialNum,y=numword, color=condition))+geom_jitter(alpha=.01)+ geom_smooth()+
          labs(y="Words per reference", x="Trial Number")+
        theme(legend.position="none", legend.title=element_blank(), axis.title = element_text(size=8))+
        scale_x_continuous(limits=c(1,24), breaks=c(6,12,18,24))+
        ggthemes::scale_color_solarized()
        
        utts <- annotated |> filter(numword>0) |>
          group_by(gameId, trialNum, condition) |> tally() |> full_join(possible) |> 
          mutate(n=ifelse(is.na(n),0,n)) |> 
  ggplot(aes(x=trialNum, y=n, color=condition))+geom_jitter(alpha=.05)+geom_smooth()+
          labs(y="References per trial", x="Trial Number")+
        theme(legend.position="none", legend.title=element_blank(), axis.title = element_text(size=8))+
        scale_x_continuous(limits=c(1,24), breaks=c(6,12,18,24))+
        ggthemes::scale_color_solarized()
        
        top <- plot_grid(all_words, words, utts,nrow=1, labels="AUTO")
        plot_grid(top, legend, nrow=2, rel_heights=c(1,.15))

```

## Textual annotations

```{r, include=F}
vb <- read_csv(here(annotation_path, "vb_agreement.csv")) %>% rename(vb_span=span,vb_referent=referent) %>% 
  mutate(vb_span=ifelse(str_starts(vb_span, "the "), str_sub(vb_span, 5, -1), vb_span)) %>% 
  mutate(row=row_number())
bl <- read_csv(here(annotation_path, "bl_agreement.csv")) %>% rename(bl_span=span,bl_referent=referent) %>% 
  mutate(bl_span=str_sub(bl_span, 2,-2)) %>% #remove quote marks
  mutate(row=row_number())

both <- vb %>% full_join(bl) %>% 
  mutate(same_span=ifelse(vb_span==bl_span, 1,0),
         same_ref=ifelse(vb_referent==bl_referent, 1,0)) %>% 
  select(text,vb_span, bl_span, vb_referent,bl_referent, same_span, same_ref) |> 
  filter(!(is.na(vb_span)&is.na(bl_span)))

raw_rows <- vb |> select(text) |> nrow()
vb |> select(gameId) |> unique() |> nrow()


agree_span <- both %>% group_by(same_span) |> tally() |> filter(same_span==1) |> pluck(2)


count <- both %>% filter(!is.na(bl_referent))

agree_target <- count |> group_by(same_ref) %>% tally() |> filter(same_ref==1) |> pluck(2)

```

We annotated the chat transcripts to extract all referring expressions and identify which flower image each expression referred to. We corrected the referring expressions for spelling errors. Annotations were done primarily by the first author, with some done by a research assistant. 

Two games consisting of `r raw_rows` utterances were annotated by both annotators.  `r nrow(both)` utterances were identified as containing reference expressions by at least one annotator; of these annotators agreed on the exact reference expression for `r agree_span` (`r round(agree_span/nrow(both)*100)`%) of the cases. The second annotator only coded the target of the referring expression for `r nrow(count)` of the utterances. Of these, the two annotators agreed on the target in `r agree_target` (`r round(agree_target/nrow(count)*100)`%) of cases. We take this level of interannotator agreement as an indication that the reference spans and targets were identified reliably. 

We extracted a total of `r annotated |> filter(numword>0) |>  tally()` referring expressions. 


## SBERT embeddings
Following recent work by @hawkins2020 and @boyce2022, we used tools for natural langauge processing to quantify similarity between phrases in order to assess the dynamics of convergence to conventions. 

We embedded each of the extracted referring expressions using SBERT [@reimers2019] which maps each utterance to a vector in a high-dimensional semantic space. We use cosine distance between pairs of vector embeddings as a measure of similarity between the corresponding referring expressions.  Higher cosine values correspond to vectors close together, and thus, reference expressions with more similar meanings. Some examples of pairs of referring expressions and their similarities are shown in Table \ref{costable}. 

For pairwise comparisons between referring expressions produced during the game, we smoothed out the random sampling and sparseness of which flowers were presented on the same trial by comparing descriptions with those from the same trial and the two later trials (thus the similarity at trial 10 comes from 10-10, 10-11 and 10-12 comparisons). 

## Analytic methods
All models were run using rstan [@rstan]. We coded condition as 0 for individual utilities (baseline condition) and 1 for shared utilities. 


# Results

We address each of the questions of interest listed at the end of the Introduction in order. 

## Reduction of referring expressions


```{r}
possible <- d.rounds.final |> select(-name) |> unique()

per_game <-  annotated |> group_by(gameId, trialNum, condition) |> select(flower) |> unique() |> tally() |> full_join(possible) |> 
  mutate(n=ifelse(is.na(n),0,n)) 

mean_flowers <- per_game |> group_by(condition) |> summarize(mean=mean(n) |> round(2), sd=sd(n) |> round(2), summ=str_c(mean," (sd: ",sd,")")) |> 
  select(condition, summ)

per_person <- annotated |> group_by(gameId, trialNum, condition, player, name) |> select(flower) |> unique() |> tally() |> full_join(d.rounds.final) |> 
  mutate(n=ifelse(is.na(n),0,n))
mean_person <- per_person |> group_by(condition) |> summarize(mean=mean(n) |> round(2), sd=sd(n) |> round(2), summ=str_c(mean," (sd: ",sd,")")) |> 
  select(condition, summ)
```

```{r,eval=F, include=F}

m1 <- stan_lmer(numword ~ trialNum + condition + (1|gameId)+ (1|player)+(1|flower), data=annotated) |> write_rds(here(model_path,"m1.rds"))
show_summary_rstan(m1) |> write_rds(here(model_path,"word_model.rds"))
```

```{r}

word_count <- read_rds(here(model_path,"word_model.rds")) |> filter(str_detect(Term,"\\[", negate=T)) #because there are problems with a couple mixed effects getting through
```

In each trial of the game, there were 6 flowers visible on the screen, and participants wanted to each pick a different one. In general, each trial contained references to 2 or 3 distinct flowers (individual utilities: mean of `r  mean_flowers |> pluck(2,1)`, shared utilities: `r mean_flowers |> pluck(2,2)`). Most players referred to one flower each trial (individual utilities: `r  mean_person |> pluck(2,1)`, shared utilities: `r mean_person |> pluck(2,2)`). 

The amount of referring language decreased over the course of the game, consistent with the dyadic reference game pattern. As shown in Figure \ref{wordcount}A, the number of words of referring language decreased across the game (trial: `r stats_text(word_count,3)`). The reduction in referring language was driven by shortening referring expressions (Figure \ref{wordcount}B), while the total number of referring expressions per trial remained constant (Figure \ref{wordcount}C). See Table \ref{extable}, flowers 1 and 2, for examples of reduction.

## Convergence of referring expressions

The classic reference game phenomenon of convergence to partner-specific referring expressions can be quantified using similarity metrics as the combination of three patterns occurring over time: 1) within a group, descriptions of the same flower converge, 2) within a group, descriptions of different flowers diverge, and 3) between groups, descriptions of the same flower diverge. We assess all of these in two ways: 1) comparing referring expressions within the game to other referring expressions from the same time to get at the dynamic changes, and 2) comparing referring expressions within the game to the names players gave the flowers after the game, to track how expressions evolve towards these final conventions. 


```{r, include=F,}

 d.raw_chat <- read_csv(here(paste(read_data_path, 
                                   "raw_chat.csv", 
                                   sep="")),
                       col_types = cols()) %>% distinct() |> 
   select(gameId, playerId) |> unique()
 
 d.players <- read_csv(here(paste(read_data_path, "players.csv", sep = "")),
                       col_types = cols()) %>% distinct() |> select(playerId,name) |> inner_join(d.raw_chat)

 sbert_single <- read_csv(here(annotation_path,"pre_sbert.csv"))|> 
    left_join(d.players) |> left_join(d.games.final) |> mutate(seen="game") |> 
   select(playerId, gameId, condition, text=normalized_span,referent, color, trialNum, seen) |> bind_cols(readRDS(here(annotation_path,'post_sbert.RData'))  %>% as_tibble())

sbert_post_test <- read_csv(here(annotation_path,"post_test_pre_sbert.csv")) |> 
  mutate(trialNum=25) |> 
 bind_cols(readRDS(here(annotation_path,'post_sbert_post_test.RData'))  %>% as_tibble()) |> inner_join(d.games) |> 
   select(playerId, gameId, condition, text,referent=num, color, trialNum, seen, starts_with("V"))

sbert_all <- sbert_single |> union(sbert_post_test)
F_mat <- sbert_all %>% select(starts_with("V")) %>% as.matrix() #Features
M_mat <- sbert_all %>% 
  select(-starts_with("V")) %>% 
  mutate(feature_ind=row_number())
```

```{r helpers}
# note: cor expects features to be in columns so we transpose
get_sim_matrix = function(df, F_mat, method = 'cosine') {
  feats = F_mat[df$feature_ind,]
  if(method == 'cor') {
    return(cor(t(feats), method = 'pearson'))
  } else if (method == 'euclidean') {
    return(as.matrix(dist(feats, method = 'euclidean')))
  } else if (method == 'cosine') {
    return(as.matrix(lsa::cosine(t(feats))))
  } else {
    stop(paste0('unknown method', method))
  }
}

# note this does de-duplicated version
flatten_sim_matrix <- function(cormat, ids) {
  ut <- upper.tri(cormat)
  data.frame(
    dim1 = ids[row(cormat)[ut]],
    dim2 = ids[col(cormat)[ut]],
    sim  = as.numeric(cormat[ut])
  ) %>%
    mutate(dim1 = as.character(dim1),
           dim2 = as.character(dim2))
}

make_across_df <- function(M_mat, F_mat, method) {
  M_mat %>%
    do(flatten_sim_matrix(get_sim_matrix(., F_mat, method = method),
                          as.character(.$combinedId)))
}
```


```{r, cache=T}

# by trial
flower_all <- M_mat %>% 
  filter(seen %in% c("game")) |> 
  group_by(color,condition) %>% 
  mutate(combinedId=str_c(referent,"_", trialNum, "_",gameId,"_",playerId)) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, c("ref1", "trialNum1","game1","player1"), convert=T) |> 
  separate(dim2, c("ref2", "trialNum2", "game2", "player2"), convert=T) |> 
 # rename(referent1=dim1,referent2=dim2) %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  #filter(ref1!=ref2) %>% 
  mutate(earlier=ifelse(trialNum1>trialNum2,trialNum2, trialNum1) |> as.numeric(),
         later=ifelse(trialNum1>trialNum2, trialNum1,trialNum2) |> as.numeric()) |> 
  ungroup()
```

```{r, eval=F}
within_game_flower <- flower_all |> 
  filter(game1==game2) |> 
  filter(ref1==ref2) |> 
  filter(later-earlier<3) |> 
  mutate(same_player=ifelse(player1==player2,1,0),
         flower=str_c(color,ref1)) |> 
  select(sim, condition, earlier, same_player, game1, flower )

m_samegame_sameflower <-  stan_lmer(sim ~ condition*earlier*same_player + 
                                      (1|game1)+(1|flower), data=within_game_flower) |> write_rds(here(model_path,"m2.rds"))

read_rds(here(model_path,"m2.rds")) |> 
show_summary_rstan() |> write_rds(here(model_path,"samegame_sameflower_model.rds"))

within_game_between_flower <- flower_all |> 
  filter(game1==game2) |> 
  filter(ref1!=ref2) |> 
  filter(later-earlier<3) |> 
  mutate(same_player=ifelse(player1==player2,1,0)) |> 
  select(sim, condition, earlier, same_player, game1)

m_samegame_diffflower <-  stan_glm(sim ~ condition*earlier*same_player, data=within_game_between_flower) |> write_rds(here(model_path,"m3.rds"))

read_rds(here(model_path,"m3.rds")) |> show_summary_rstan() |> write_rds(here(model_path,"samegame_diffflower_model.rds"))

within_game_between_flower <- flower_all |> 
  filter(game1==game2) |> 
  filter(ref1!=ref2) |> 
  filter(later-earlier<3) |> 
  mutate(same_player=ifelse(player1==player2,1,0)) |> 
  select(sim, condition, earlier, same_player, game1)

m_samegame_diffflower <-  stan_glm(sim ~ condition*earlier*same_player, data=within_game_between_flower) |> write_rds(here(model_path,"m3.rds"))

read_rds(here(model_path,"m3.rds")) |> show_summary_rstan() |> write_rds(here(model_path,"samegame_diffflower_model.rds"))

```

```{r}
wi_g_wi_f <- read_rds(here(model_path,"samegame_sameflower_model.rds"))

wi_g_bet_f <- read_rds(here(model_path,"samegame_diffflower_model.rds"))

bet_g_wi_f <- read_rds(here(model_path,"diffgame_sameflower_model.rds"))
```



### Within games

Within games, the patterns from dyadic reference games predict that similarity for descriptions of the same image will increase over time while similarity for descriptions of different images will decrease over time. Table \ref{extable} offers examples of how some descriptions changed over time, and Table \ref{costable} gives similarity measures between selected pairs of these descriptions. 

We found that for descriptions of the same flower, cosine similarity increased over time (trial: `r stats_text(wi_g_wi_f,6)`, see Figure \ref{during} upper left and middle panels). Utterances were more similar if they were produced by the same participant (`r stats_text(wi_g_wi_f,8)`), although this did not interact with trial number (`r stats_text(wi_g_wi_f,7)`). 

For descriptions of different flowers, cosine similarity decreased over time (trial: `r stats_text(wi_g_bet_f,6)`, see Figure \ref{during} lower left and middle panels). There was not an effect of utterances being produced by the same person (`r stats_text(wi_g_bet_f,8)`), or interactions between who said it and trial number (`r stats_text(wi_g_bet_f,7)`) . 

These results are consistent with the reference game phenomenon. 
 
```{r}

include <- tribble(
  ~gameId, ~name, ~flower, ~trialNum, ~normalized_span,
  "cK5bFKgBKPiq4oCki", "Laju", "11yellow", 1, "not sure what kind of flower it is but the droopy-ish one",
  "cK5bFKgBKPiq4oCki", "Repi", "11yellow", 3, "droopy iris flower",
  "cK5bFKgBKPiq4oCki", "Minu", "11yellow", 20, "droopy",
  "DTw5mrEvPvfyuEiGw", "Minu", "2yellow", 1, "the red middle with spike",
    "DTw5mrEvPvfyuEiGw", "Minu", "2yellow", 2, "the red center",
    "DTw5mrEvPvfyuEiGw", "Laju", "2yellow", 19, "red middle",
  "KiRHskdD2iLy8Fh8C", "Repi", "2yellow", 5, "the one with the dark red centre",
    "KiRHskdD2iLy8Fh8C", "Laju", "2yellow", 12, "the one with black background",
      "KiRHskdD2iLy8Fh8C", "Laju", "2yellow", 23, "black background",
    "cK5bFKgBKPiq4oCki", "Laju", "4yellow", 3, "the big cluster of flowers with the orange in the middle",
      "cK5bFKgBKPiq4oCki", "Laju", "4yellow", 22, "cluster",
      "DTw5mrEvPvfyuEiGw", "Repi", "4yellow", 23, "bundle",
        "KiRHskdD2iLy8Fh8C", "Minu", "4yellow", 23, "multi flowers",
)

# note sbert_examples are generated by running sbert process just on include 
examples <- read_rds(here(model_path,"sbert_examples.rds")) |> left_join(include, by=c("game1"="gameId","ref1"="flower","player1"="name","trialNum1"="trialNum")) |> rename(text1=normalized_span) |> left_join(include, by=c("game2"="gameId","ref2"="flower","player2"="name","trialNum2"="trialNum")) |> rename(text2=normalized_span)

```

```{r examples}
text_examples <- include |> 
  mutate(Game=as.factor(gameId) |> as.numeric() |> as.character(),
         Player=LETTERS[as.factor(name) |> as.numeric()],
         GamePlayer=str_c(Game,Player),
         Trial=trialNum+1,
         Flower=as.factor(flower) |> as.numeric() |> as.character()) |> arrange(Flower,Game,Trial) |> 
  select(Flower,Game=GamePlayer, Trial,  Expression=normalized_span )

knitr::kable(text_examples, caption = "Examples of descriptions of different flowers from different games, illustrating reduction and convergence phenomenon. Games are numbered, letters refer to players within games. Images of flowers can be found in Figure 1: flower 1 upper left, flower 2 lower center, flower 3 lower left. \\label{extable}",  format="latex", booktabs=TRUE, linesep="") %>%
kable_styling(full_width = F) %>%
  row_spec(c(3,9), hline_after=T) |> 
column_spec(4, width = "12em") %>%
  kable_styling(latex_options="H")

```



```{r sbert-example}
sbert_include <- tribble(
  ~text1, ~text2,
  #"the red center", "the one with the dark red centre",
  "the red center", "red middle",
  "droopy iris flower", "droopy",
  "cluster", "bundle",
  "droopy iris flower","the red center", 
  "droopy iris flower","multi flowers", 
  "red middle", "black background",
  "droopy", "bundle",
) |> left_join(examples) |> arrange(desc(sim)) |> mutate(sim=round(sim,2)) |> select(`Expression 1`=text1, `Expression 2`=text2, `Sim`=sim)


knitr::kable(sbert_include, caption = "Examples of cosine similarities between pairs of descriptions. \\label{costable}",  format="latex", booktabs=TRUE, linesep="") %>%
kable_styling(full_width = F) %>%
column_spec(c(1,2), width = "9em") %>% 
  kable_styling(latex_options="H")

```

```{r during, fig.env = "figure*", fig.pos = "h", fig.align = "center", set.cap.width=T, num.cols.cap=2, fig.cap = "Cosine similarities between SBERT embeddings of utterances produced within 2 trials of each other. Utterances were paired with other utterances from the same speaker; from the same game, but a different speaker; or from a different game (vertical panels). Utterances were either in reference to the same flower or different flowers (horizontal panels). \\label{during}", fig.height=4, fig.width=10, out.width="80%"}
flower_all|> 
  filter(later-earlier<3) |> 
  mutate(distance=case_when(
    player1==player2 ~ "Same Person",
    game1==game2 ~ "Same Game - Different Person",
    T ~ "Different Games"),
    same_flower=ifelse(ref1==ref2, "Same Flower", "Different Flowers")
  ) |> mutate(same_flower=factor(same_flower,levels=c("Same Flower", "Different Flowers")),
              distance=factor(distance, levels=c("Same Person", "Same Game - Different Person", "Different Games"))) |> 
ggplot( aes(x=earlier,y=sim,color=condition))+     
  stat_summary(aes(group=str_c(color,condition), color=condition),fun.data = "mean_cl_boot", position = position_dodge(width=.3), alpha=.3, geom="point")+
  geom_smooth(formula=y~poly(x,2))+facet_grid(same_flower~distance)+theme(legend.position="bottom", legend.title=element_blank())+
        scale_x_continuous(limits=c(1,24), breaks=c(6,12,18,24))+
        ggthemes::scale_color_solarized()+
  labs(x="Trial Number", y="Cosine Similarity")+
  guides(color = guide_legend(override.aes = list(linetype = NA, alpha=1, fill=NA, size=5) ) )

```
### Between games

The theory of partner-specificity predicts that descriptions to the same flower in different groups will diverge over time as each group forms their own distinct convention. Table \ref{extable} shows how groups descriptions of the same flower may diverge (flower 2), but also how groups might choose related but different descriptions (flower 3). 

For descriptions of the same flower across games, we found that cosine similarities decreased slightly over time  (trial: `r stats_text(bet_g_wi_f,4)`, see Figure \ref{during} upper right panel). This is weakly consistent with the predictions. 


```{r, cache=T}

# by trial
to_end <- M_mat %>% 
  filter(seen %in% c("game", "own")) |> 
  group_by(gameId,color,condition) %>% 
  mutate(combinedId=str_c(referent,"_", trialNum, "_",seen,"_",playerId)) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, c("ref1", "trialNum1","seen1","player1"), convert=T) |> 
  separate(dim2, c("ref2", "trialNum2", "seen2", "player2"), convert=T) |> 
 # rename(referent1=dim1,referent2=dim2) %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  filter(seen1!=seen2) %>% 
  mutate(earlier=ifelse(trialNum1>trialNum2,trialNum2, trialNum1) |> as.numeric(),
         later=ifelse(trialNum1>trialNum2, trialNum1,trialNum2) |> as.numeric()) |> 
  ungroup()
```

```{r, cache=T}
in_end <- M_mat %>% 
  filter(seen %in% c("own")) |> 
  group_by(color,condition) %>% 
  mutate(combinedId=str_c(referent, "_",seen,"_", gameId, "_",playerId)) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, c("ref1", "seen1","game1","player1"), convert=T) |> 
  separate(dim2, c("ref2",  "seen2","game2", "player2"), convert=T) |> 
 # rename(referent1=dim1,referent2=dim2) %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  ungroup()
```


```{r toend, fig.env="figure", fig.pos = "h", fig.align = "center", out.width="100%", fig.cap = "Cosine similarities between SBERT embeddings of utterances produced during a game and the post-game descriptions of the flowers. \\label{toend}", fig.height=4, fig.width=6}
to_end|> 
  mutate(distance=case_when(
    player1==player2 ~ "Same Person",
    T ~ "Same Game - Different Person"),
        same_flower=ifelse(ref1==ref2, "Same Flower", "Different Flowers")
) |> mutate(same_flower=factor(same_flower,levels=c("Same Flower", "Different Flowers")),
              distance=factor(distance, levels=c("Same Person", "Same Game - Different Person" ))) |> 
ggplot( aes(x=earlier,y=sim,color=condition))+     
  stat_summary(aes(group=str_c(color,condition), color=condition),fun.data = "mean_cl_boot", position = position_dodge(width=.3), alpha=.3, geom="point")+
  geom_smooth(formula=y~poly(x,2))+facet_grid(same_flower~distance)+theme(legend.position="bottom", legend.title=element_blank())+
        scale_x_continuous(limits=c(1,24), breaks=c(6,12,18,24))+
        ggthemes::scale_color_solarized()+
  guides(color = guide_legend(override.aes = list(linetype = NA, alpha=1, fill=NA, size=5) ) )

```


```{r, eval=F}
to_end_same_flower <- to_end |> 
  filter(ref1==ref2) |> 
  mutate(same_player=ifelse(player1==player2,1,0),
         flower=str_c(color,ref1)) |> 
  select(sim, condition, earlier, same_player, gameId, flower)

m_to_end_sameflower <-  stan_glm(sim ~ condition*earlier*same_player, data=to_end_same_flower) |> write_rds(here(model_path,"m5.rds"))

read_rds(here(model_path,"m5.rds")) |> show_summary_rstan() |> write_rds(here(model_path,"to_end_sameflower_model.rds"))

to_end_diff_flower <- to_end |> 
  filter(ref1!=ref2) |> 
  mutate(same_player=ifelse(player1==player2,1,0)) |> 
  select(sim, condition, earlier, same_player, gameId)

m_to_end_diffflower <-  stan_glm(sim ~ condition*earlier*same_player, data=to_end_diff_flower) |> write_rds(here(model_path,"m6.rds"))

read_rds(here(model_path,"m6.rds")) |> show_summary_rstan() |> write_rds(here(model_path,"to_end_diffflower_model.rds"))

within_end <- in_end |> 
  filter(seen1=="own" & seen2=="own") |> 
  filter(player1!=player2) |> 
  mutate(same_flower=ifelse(ref1==ref2, 1, 0),
         same_game=ifelse(game1==game2, 1,0)) |> 
  select(sim, condition, same_flower, same_game)

m_within_end <-  stan_glm(sim ~ condition*same_flower*same_game, data=within_end) |> write_rds(here(model_path,"m7.rds"))


read_rds(here(model_path,"m7.rds")) |> show_summary_rstan() |> write_rds(here(model_path,"within_end.rds"))

```

```{r}
to_e_wi_f <- read_rds(here(model_path,"to_end_sameflower_model.rds"))

to_e_bet_f <- read_rds(here(model_path,"to_end_diffflower_model.rds"))

wi_e <- read_rds(here(model_path, "within_end.rds"))
```

### Comparison with post-game convention reports

After the game, players provided the description they would use to identify each flower to their teammates. We treated these descriptions as the conventionalized names and looked at how the in-game descriptions developed into these conventions. 

Referring descriptions later in a game were more similar to the convention than descriptions earlier in the game  (trial: `r stats_text(to_e_wi_f,6)`, see Figure \ref{toend} upper panels). Utterances were more similar to the convention given by the same person (versus the convention given by a groupmate) (`r stats_text(to_e_wi_f,8)`), although this did not interact with trial number (`r stats_text(to_e_wi_f,7)`). This is consistent with the expected pattern of convention formation. 

We also examined how referring expressions related to the conventionalized names for other flowers. Utterances diverge from the conventionalized names of other flowers over time (trial: `r stats_text(to_e_bet_f,6)`, see Figure \ref{toend} lower panels).  There was no effect of the same person saying the description and convention (`r stats_text(to_e_bet_f,8)`) and no interaction between same person and trial number (`r stats_text(to_e_bet_f,7)`). 

```{r withinend, fig.env="figure", fig.pos = "h", fig.align = "center", out.width="90%", fig.width=4, fig.height=2, fig.cap = "Cosine similarities between flower descriptions provided by participants after the game. \\label{withinend}"}
in_end|> 
  filter(player2!=player1) |> 
  mutate(distance=case_when(
    game1==game2 ~ "Same group",
    T ~ "Different group"),
    same_flower=ifelse(ref1==ref2, "Same flower", "Different flower"))|> 
ggplot( aes(x=str_c(same_flower,"\n", distance),y=sim,color=condition))+
  labs(y="Cosine Similarity", x=NULL)+
  stat_summary(fun.data = "mean_cl_boot", position = position_dodge(width=.3))+theme(legend.position=c(0.2,.75), legend.title=element_blank(), legend.background=element_blank())+
        ggthemes::scale_color_solarized()
```
## Individual and shared utility conditions 

The last question of interest is whether there were differences between the individual and shared utility conditions. Here we report the extent to which the shared utility condition differed from the individual utility condition. Overall, there was not a significant difference in the amount of referring language produced in the two conditions (`r stats_text(word_count,2)`). 

### Within games
Games in the shared utilities condition had slightly higher cosine similarities between descriptions of the same flower within games (`r stats_text(wi_g_wi_f,2)`), but this did not interact with trial number (`r stats_text(wi_g_wi_f,3)`) or whether the utterances were produced by the same participant (`r stats_text(wi_g_wi_f,5)`). As a complement to this, games in the shared utilities condition had slightly lower similarities between descriptions of different flowers within games, but this did not interact with trial (`r stats_text(wi_g_bet_f,3)`) or whether the utterances were produced by the same player (`r stats_text(wi_g_bet_f,5)`). 

Comparing to the end conventions, games in the shared utility condition produced flower descriptions that were more similar to the convention for that flower (`r stats_text(to_e_wi_f,2)`), but this did not interact with trial number (`r stats_text(to_e_wi_f,3)`) and did not significantly interact with same participant versus different participant (`r stats_text(to_e_wi_f,5)`).  In the shared utility condition, descriptions were slightly less similar to the conventions for other flowers (`r stats_text(to_e_bet_f,2)`), but this did not interact with trial (`r stats_text(to_e_bet_f,3)`). There was an interaction between shared utility condition and the referring expression coming from the same person who gave the convention for the different flower (`r stats_text(to_e_bet_f,5)`). Taken together, groups in the shared utility had more internal alignment on the mapping between flowers and names. 

### Between games
Across different games, games in the shared utility condition tended to have more similar descriptions for the same flower (`r stats_text(bet_g_wi_f,2)`); this did not interact with trial (`r stats_text(bet_g_wi_f,3)`). 

Lastly, we can look at how the conventionalized names compared, both between members of the same group and across players in different groups that saw the same color palette of flowers, and whether this differs by condition. 

We treat different flowers described by different games as the baseline condition. For individual utility games, descriptions from groupmates are more similar (even for different flowers, `r stats_text(wi_e,8)`), descriptions of the same flower are more similar (even across games, `r stats_text(wi_e,6)`), and there is a large interaction effect, where descriptions of the same flower are very similar among groupmates (`r stats_text(wi_e,7)`). 

For shared utility games compared to individual utility games, descriptions are roughly equivalent at baseline (`r stats_text(wi_e,2)`) and for descriptions from groupmates (`r stats_text(wi_e, 5)`). Descriptions are much more similar for the same flower (even across games, `r stats_text(wi_e,3)`), but this is balanced out by a negative interaction effect between same flower and same game (`r stats_text(wi_e,4)`).

These findings are suggestive that in the shared utility condition, games differentiated less from each other, and their conventions may have been influenced more by shared priors for how to describe the flowers. 

# Discussion

This analysis of the referring expressions in @mankewitz2021 examined three key questions: the reduction of referring expressions, the convergence of referring expressions to conventions, and the differences between the shared and individual utility conditions. 

First, we saw reduction, as referring expressions tended to decrease in length over the course of the game. Second, we found the expected set of convergence and divergence patterns. References to the same flower within a game converged both to other descriptions used at that timepoint and to the post-game descriptions. This convergence was specific to flower and games, as references to different flowers within a game and references to the same flower across games both diverged.  

These patterns of reduction and convergence confirm some generalizability of the reference game patterns to the freer-form and more naturalistic domain of a negotiation game. While still artificial, this game differed from classic reference games in that the set-up was symmetric, with all players having equivalent amounts of knowledge and authority, and that the need for reference was embedded within a more complex goal structure. This game also was atypical for reference games in that it had more than 2 players [although see @boyce2022; @yoonAudienceDesignMultiparty2019] and used photos as target images [although see @weber2003].

Our third consideration was how the different utility conditions moderated the reduction and convergence effects. We found slight condition differences where being in the shared utility condition meant more similar descriptions for the same flowers and more different descriptions for different flowers. In addition, groups in the shared utility condition diverged less from each other. This pattern of condition differences is consistent with less idiosyncratic descriptions in the shared utility condition. 

The greater alignment between players (and between games) in the shared utility condition might be due to a perceived greater importance of communicating with each other and understanding what others say, possibly triggered by the cooperative goal. The similarity across games is particularly intriguing given @guilbeault2021, which found that larger groups tend to all converge to similar conventions whereas smaller groups can support idiosyncratic conventions. 

However, we are cautious not to over-interpret the condition differences. There were a limited number of groups in each condition, so these effects may have been driven or exacerbated by heterogeneity in which participants were in each group. These ideas will need to be tested further with larger samples and more different goal structures. 

Our interpretation of results is limited by the dataset, which is small, especially compared to recent datasets of convention formation in reference games [@hawkins2020, @boyce2022]. The dataset also has large item-level variation, as the images differ in how nameable the flowers are or whether there are salient features. 

This dataset is just the start of testing how well findings from reference games generalize to more complex conversational situations. One dimension that we were unable to explore here due to the design of the game is the idea of shared versus privileged knowledge [@keysar2000taking; @heller2008role]. In the flowers game, like in reference games, all players saw the same set of images (and knew they did), which makes making descriptions to flowers easier. In real-world situations, interlocuters may have different sets of objects in their context and may not know what is in their interlocuters context. An important future direction is studying how repeated reference phenomena interact with different communication forms such as goals and contexts. 

In conclusion, this analysis showed that the phenomenon of reduction and conventionalization occurs even in complex games with different incentives, asymmetric knowledge, and more open-ended negotiation and dialogue than that found in reference games. Additionally, we saw hints that different incentives may lightly moderate the formation of conventions, but that reduction and convention formation took place regardless of incentive condition. We hope future work will continue to develop our understanding of these phenomena in more natural settings. 


# References 

```{r}
# References will be generated automatically by Pandoc and included here.
# The following code is some latex to format the bibliography. Do not remove it.
```

\setlength{\parindent}{-0.1in} 
\setlength{\leftskip}{0.125in}
\noindent
\small
